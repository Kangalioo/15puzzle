#include "/home/kangalio/devel/tiasm/lib/incFiles.inc"

.org 9327h
main:
	call	initialize
	call	readDimensions
	call	chooseAction
	call	finalize
	ret
;main

#include "/home/kangalio/devel/tiasm/lib/shuffle.z80"

chooseAction:
	call	_ClrLCDFull
	call	_HomeUp
	ld	hl, chooseActionStr1
	call	_PutS
	call	_NewLine
	ld	hl, chooseActionStr2
	call	_PutS
	call	_NewLine
	ld	hl, chooseActionStr3
	call	_PutS
	call	_NewLine
	
	call	_GetKey
	call	exitIfRequested
	cp	k1
	jr	z, _ca_play
	cp	k2
	jr	z, _ca_editLayout
_ca_repeat:
	jr	chooseAction
_ca_editLayout:
	call	enterEditMode
	jr	_ca_repeat
_ca_play:
	call	enterPlayMode
	jr	_ca_repeat
	
	ret
;chooseAction

generateLevel:
	ld	a, (amountOfWalls)
	ld	b, a
	ld	a, (dataFieldSize)
	sub	b
	ld	(rawDataFieldSize), a
	
	call	fillWithAscending
	call	shuffle
	; Now we've got the shuffled array of numbers in rawDataField,
	; but there are no walls in them. We have to put the contents of
	; rawDataField together with the walls in dataField. The position
	; of the zero from rawDataField in dataField will be stored
	; in currFreeCell.
	; 
	; rawDataField and dataField might look like this:
	; rawDataField: 3, 2, 0, 1, 4
	; dataField (before): 0, 255, 0, 0, 0, 255, 0, 255, 255
	; dataField (after): 3, 255, 2, 0, 1, 255, 4, 255, 255
	; currFreeCell: 3
	
	ld	c, 0 ; Address in rawDataField
	ld	e, 0 ; Address in dataField
_gl_loop:
	; Check if dataField[e] is wall. If true, then
	; skip setting dataField[e] to rawDataField[c].
	ld	hl, dataField
	ld	d, 0
	add	hl, de
	ld	a, (hl)
	cp	WALL_CELL
	jr	z, _gl_incrementAndJump
	
	; dataField[e] = rawDataField[c++]
	push	de
	ex	de, hl ; Reuse generated dataField[e] address from above
	ld	hl, rawDataField
	ld	b, 0
	add	hl, bc
	ld	a, (hl)
	cp	FREE_CELL
	jr	nz, _gl_dontSetCurrFreeCell
	ld	a, e
	ld	(currFreeCell), a
_gl_dontSetCurrFreeCell:
	ld	a, (hl)
	ld	(de), a
	inc	c
	pop	de
	
_gl_incrementAndJump:
	inc	e
	ld	a, (dataFieldSize)
	ld	b, a
	ld	a, e
	cp	b
	jr	nz, _gl_loop
	
	ret
;generateLevel

enterPlayMode:
	call	_ClrLCDFull
	ld	a, 3
	ld	(CurRow), a
	ld	a, 1
	ld	(CurCol), a
	ld	hl, lvlGenerateMsg
	call	_PutS
	call	generateLevel
	call	_ClrLCDFull
	
	ld	hl, keyPressActionPlay ; This is a function pointer
	ld	(keyPressAction), hl
	ld	hl, dispActionPlay
	ld	(dispAction), hl
	
	call	startSession
	
	ret
;playLevel

.echo	"Enter Edit Mode: "
.echo	$
.echo	".\n"
enterEditMode:
	call	_ClrLCDFull
	
	ld	hl, keyPressActionEdit ; This is a function pointer
	ld	(keyPressAction), hl
	ld	hl, dispActionEdit
	ld	(dispAction), hl
	
	call	startSession
	
	ret
;enterEditMode

initialize:
	res	AppAutoScroll, (IY + AppFlags) ; Disable scrolling
	res	IndicRun, (IY + IndicFlags) ; Disable run indicator
	
	ret

;initialize

finalize:
	set	IndicRun, (IY + IndicFlags) ; Enable run indicator
	set	AppAutoScroll, (IY + AppFlags) ; Enable scrolling
	
	call	_ClrScrnFull
	call	_HomeUp
	
	ret
;finalize

;~ play:
	;~ call	_GetKey
	;~ cp	kQuit
	;~ jr	z, _p_ret
	;~ cp	kClear
	;~ jr	z, _p_ret
	
	;~ call	executeMove
	
	;~ call	_ClrLCDFull
	;~ call	redrawField
	;~ jr	play
;~ _p_ret
	;~ ret
;~ ;play

;~ calculateDataFieldPos:
	;~ call	posOfKey
	;~ ld	a, (keyOffset)
	;~ ld	c, a
	;~ ld	a, b
	;~ sub	c
	;~ ld	b, a
	;~ cp	255 ; Code returned by posOfKey function for unknown key
	;~ jr	z, _cdfp_ret
	;~ and	111000b ; Extract row
	;~ srl	a
	;~ srl	a
	;~ srl	a
	;~ ld	h, a
	;~ ld	a, (width)
	;~ ld	e, a
	;~ push	bc ; To keep 'b'
	;~ call	hTimesE
	;~ pop	bc
	;~ ld	a, b
	;~ and	000111b ; Extract column
	;~ ld	d, 0
	;~ ld	e, a
	;~ add	hl, de
;~ _cdfp_ret:
	;~ ret
;~ ;calculateDataFieldPos

; Number to be moved is in 'hl'.
validateKey:
	; STUB
	
	ret

;~ executeMove:
	;~ call	calculateDataFieldPos
	;~ call	validateKey
	;~ push	hl
	;~ ld	de, dataField
	;~ add	hl, de
	;~ ld	d, (hl)
	;~ ld	a, FREE_CELL
	;~ ld	(hl), a
	;~ ld	hl, dataField
	;~ ld	b, 0
	;~ ld	a, (currFreeCell)
	;~ ld	c, a
	;~ add	hl, bc
	;~ ld	(hl), d
	
	;~ ; Update currFreeCell
	;~ pop	hl
	;~ ld	a, l
	;~ ld	(currFreeCell), a
	
	;~ ret
;~ ;executeMove

;~ edit:
	;~ call	_GetKey
	;~ cp	kEnter
	;~ jr	z, _e_toggleCell
	;~ cp	kQuit
	;~ jr	z, _e_ret
	;~ cp	kClear
	;~ jr	z, _e_ret
	;~ call	processMove
;~ _e_redrawField:
	;~ call	redrawField
	;~ jr	edit
;~ _e_toggleCell:
	;~ ld	a, (currCellY)
	;~ ld	h, a
	;~ ld	a, (width)
	;~ ld	e, a
	;~ call	hTimesE ; Result of multiplication is in hl
	;~ ld	a, (currCellX)
	;~ ld	b, a
	;~ ld	a, l
	;~ add	a, b
	;~ ld	l, a
	;~ ld	de, dataField
	;~ add	hl, de
	;~ ld	a, (hl)
	;~ cp	wallCell
	;~ jr	z, _e_makeCellNum
;~ _e_makeCellWall:
	;~ ld	a, wallCell
	;~ jr	_e_writeCell
;~ _e_makeCellNum:
	;~ ld	a, 0
;~ _e_writeCell:
	;~ ld	(hl), a
	;~ cp	wallCell
	;~ jr	nz, _e_cellIsNowNum
;~ _e_cellIsNowWall:
	;~ ld	a, (amountOfWalls)
	;~ inc	a
	;~ jr	_e_end
;~ _e_cellIsNowNum:
	;~ ld	a, (amountOfWalls)
	;~ dec	a
;~ _e_end:
	;~ ld	(amountOfWalls), a
	
	;~ jr	_e_redrawField
;~ _e_ret:
	;~ ret
;~ ;edit

; If one of the arrow keys was pressed, adjust currCellX and currCellY accordingly.
; Assumes the key code to be in 'a'. Also destroys 'a'.
; 
; DESTROYS: 'a'
;~ processMove:
	;~ cp	kDown
	;~ jr	z, _e_down
	;~ cp	kUp
	;~ jr	z, _e_up
	;~ cp	kLeft
	;~ jr	z, _e_left
	;~ cp	kRight
	;~ jr	z, _e_right
	;~ ret
;~ _e_down:
	;~ ld	a, (currCellY)
	;~ inc	a
	;~ ld	(currCellY), a
	;~ ret
;~ _e_left:
	;~ ld	a, (currCellX)
	;~ dec	a
	;~ ld	(currCellX), a
	;~ ret
;~ _e_up:
	;~ ld	a, (currCellY)
	;~ dec	a
	;~ ld	(currCellY), a
	;~ ret
;~ _e_right:
	;~ ld	a, (currCellX)
	;~ inc	a
	;~ ld	(currCellX), a
	;~ ret
;~ ;processMove

readDimensions:
	call	_ClrLCDFull
	
	; Ask for width
	call	_HomeUp
	ld	hl, widthQuestion
	call	_PutS
	
	; Read and echo answer for width
	ld	b, 2 ; Min value (in.)
	ld	c, MAX_WIDTH + 1 ; Max value (ex.)
	call	readDigitAndEcho
	ld	(width), a
	call	_NewLine
	
	; Ask for height
	ld	hl, heightQuestion
	call	_PutS
	
	; Read and echo answer for height
	ld	b, 2 ; Min value (in.)
	ld	c, MAX_HEIGHT + 1 ; Max value (ex.)
	call	readDigitAndEcho
	ld	(height), a
	call	_NewLine
	
	; Calculate size of data field
	ld	a, (width)
	ld	h, a
	ld	a, (height)
	ld	e, a
	call	hTimesE
	ld	a, l
	ld	(dataFieldSize), a
	
	;~ ; Reset cursor (not the one from TI-OS) position
	;~ ld	a, 0
	;~ ld	(currCellX), a
	;~ ld	(currCellY), a
	
	ret
;readDimensions

exitIfRequested:
	cp	kClear
	jr	z, _eir_exit
	cp	kQuit
	jr	z, _eir_exit
	ret
_eir_exit:
	pop	hl ; Get rid of calling address, we want to jump a level above it
	ret
;exitIfRequested

.echo	"Start Session: "
.echo	$
.echo	".\n"
startSession:
	call	_ClrLCDFull
	call	redrawField
_ss_getKey:
	call	_GetKey
	cp	kQuit
	jr	nz, _ss_dontRet
	ret
_ss_dontRet:
	ld	hl, _ss_getKey
	push	hl
	ld	hl, (keyPressAction)
	jp	(hl)
	
	; No, the "ret" is not missing here. Look above.
;startSession

redrawField:
	ld	c, 0 ; Y
_rf_drawRow:
	ld	b, 0 ; X
_rf_drawCell:
	;~ ; Calculate address of cell data
	;~ ; dataField addr
	;~ ld	hl, dataField
	;~ ; + cell index
	;~ ld	d, 0
	;~ add	hl, de
	;~ ; byte at 'hl' stored into 'hl'
	;~ ld	l, (hl)
	;~ ld	h, 0
	;~ ; 'de' backup
	;~ push	de
	;~ ; Calculate address of cell char
	;~ ld	de, fieldLayoutChars
	;~ add	hl, de
	;~ ; 'de' backup
	;~ pop	de
	;~ ; Set cursor position from b (column) and c (row).
	;~ ld	a, b
	;~ ld	(CurCol), a
	;~ ld	a, c
	;~ ld	(CurRow), a
	;~ ; Generate byte addr
	;~ ld	h, c
	;~ ld	a, (width)
	;~ ld	e, a
	;~ push	bc
	;~ call	hTimesE
	;~ pop	bc
	;~ ld	a, l
	;~ add	a, b
	;~ ld	hl, dataField
	;~ ld	d, 0
	;~ ld	e, a
	;~ add	hl, de
	; Output character using dispAction
	push	bc
	ld	hl, _rf_afterCall ; Manual "call"
	push	hl ; Manual "call"
	ld	hl, (dispAction) ; Manual "call"
	jp	(hl) ; Manual "call"
_rf_afterCall:
	pop	bc
	
	; Increment loop counters and check loop condition
	inc	b
	ld	a, (width)
	cp	b
	jr	nz, _rf_drawCell
	inc	c
	ld	a, (height)
	cp	c
	jr	nz, _rf_drawRow
	
	ret
;redrawField

keyPressActionPlay:
	; STUB
	
	ret
;keyPressActionPlay

.echo	"Key press action (for edit): "
.echo	$
.echo	".\n"
keyPressActionEdit:
	call	calculateDFAFromKey
	ld	de, dataField
	add	hl, de
	ld	a, (hl)
	xor	11111111b 
	ld	(hl), a
	call	_ClrLCDFull ; REMEMBER
	call	redrawField
	
	ret
;~ keyPressActionEdit

dispActionPlay:
	; STUB
	
	ret
;~ dispActionPlay

dispActionEdit:
	ld	a, b
	add	a, b
	add	a, b
	add	a, a
	ld	(PenCol), a
	ld	a, c
	add	a, c
	add	a, c
	add	a, a
	ld	(PenRow), a
	
	call	calculateDataFieldAddress
	ld	de, dataField
	add	hl, de
	ld	a, (hl)
	cp	255
	jr	z, _dae_drawWall
_dae_drawNum:
	ld	a, 48
	jr	_dae_draw
_dae_drawWall:
	ld	a, 49 ; STUB: Replace this
_dae_draw:
	call	_VPutMap
	ret
;~ dispActionEdit

; DFA = data field address (relative, as always). Is returned in 'hl' register.
calculateDFAFromKey:
	call	posOfKey
	cp	255 ; Code returned by posOfKey function for unknown key
	jr	z, _cdfp_ret
	ld	a, (keyOffset)
	ld	c, a
	ld	a, b
	sub	c
	ld	b, a
	and	111000b ; Extract row
	srl	a
	srl	a
	srl	a
	ld	h, a
	ld	a, (width)
	ld	e, a
	push	bc ; To keep 'b'
	call	hTimesE
	pop	bc
	ld	a, b
	and	000111b ; Extract column
	ld	d, 0
	ld	e, a
	add	hl, de

_cdfp_ret:
	ret
;calculatePosFromKey

; X pos is assumed in 'b' and y pos is assumed in 'c'.
; Result (in 'hl') is relative to dataField.
.echo	"calculateDataFieldAddress: "
.echo	$
.echo	".\n"
calculateDataFieldAddress:
	; hl = c * (width)
	ld	h, c
	ld	a, (width)
	ld	e, a
	push	bc; To keep 'bc'
	call	hTimesE
	pop	bc
	
	; hl += b
	ld	d, 0
	ld	e, b
	add	hl, de
	
	ret
;calculateDataFieldAddress

;~ dispBytePlay:
	;~ ld	a, (CurCol)
	;~ ld	b, a
	;~ add	a, b
	add	a, b
	sub	3
	;~ ld	(CurCol), a
	
	;~ ld	a, (hl)
	;~ cp	FREE_CELL
	;~ jr	z, _dbp_end ; A free cell is not drawn - it's free.
	;~ cp	WALL_CELL
	;~ jr	nz, _dbp_num
;~ _dbp_wall:
	;~ ld	a, (CurCol)
	;~ add	a, 4
	;~ ld	(CurCol), a
	;~ ld	a, T_UNAVAILABLE
	;~ call	_PutC
	;~ jr	_dbp_end
;~ _dbp_num:
	;~ ld	l, (hl)
	;~ ld	h, 0
	;~ call	_DispHL
;~ _dbp_end:
	
	;~ ret
;~ ;dispBytePlay

;~ dispByteEdit:
	;~ ; Check if x matches currCell
	;~ ld	a, (currCellX)
	;~ cp	b
	;~ jr	nz, _dbe_dontInverseChar
	;~ ; Check if y matches currCell
	;~ ld	a, (currCellY)
	;~ cp	c
	;~ jr	nz, _dbe_dontInverseChar
	;~ ; Inverse text (is skipped if x or y don't match with currCell)
	;~ set	TextInverse, (IY + TextFlags)
;~ _dbe_dontInverseChar:
	;~ ; Output the character (for real this time)
	;~ ld	d, 0
	;~ ld	a, (hl)
	;~ cp	WALL_CELL
	;~ jr	z, _dbe_dispWall
;~ _dbe_dispNum:
	;~ ld	a, t0
	;~ jr	_dbe_printChar
;~ _dbe_dispWall
	;~ ld	a, T_UNAVAILABLE
;~ _dbe_printChar:
	;~ call	_PutC
	;~ ; Reset text inversion
	;~ res	TextInverse, (IY + TextFlags)
	
	;~ ret
;~ ;dispByteEdit

; Reads a digit from a key press.
; Arguments:
; 	b: Min value of digit (inclusive)
; 	c: Max value of digit (exclusive)
; Returns:
; 	a: Digit (0 - 9)
readDigitAndEcho:
	; Read key until digit in range 'b'-'c' was pressed
	push	bc
	call	_GetKey
	pop	bc
	sub	k0
	; Check if key is in range
	cp	b
	jr	c, readDigitAndEcho
	cp	c
	jr	nc, readDigitAndEcho
	
	; Echo pressed digit
	ld	b, a
	add	a, t0 ; ASCII for 0
	call	_PutC
	ld	a, b
	ret
;readDigitAndEcho

hTimesE: ; hl = h * e
	ld	d, 0 ; Zero 'd' and 'l'
	ld	l, d
	ld	b, 8
_hte_loop:
	add	hl, hl ; Get most-significant bit of 'hl'
	jr	nc, _hte_skip
	add	hl, de
_hte_skip:
	djnz   _hte_loop
	ret
;hTimesE

; CONSTANTS
MAX_WIDTH	.equ	5
MAX_HEIGHT	.equ	8
T_UNAVAILABLE	.equ	0F1h
WALL_CELL	.equ	255
FREE_CELL	.equ	0

; RAM CONSTANTS
#include "/home/kangalio/devel/tiasm/lib/scTable.inc"
widthQuestion:
	.db	"Enter width: ", 0
heightQuestion:
	.db	"Enter height: ", 0
chooseActionStr1:
	.db	"Do you want to", 0
chooseActionStr2:
	.db	" 1) Play level", 0
chooseActionStr3:
	.db	" 2) Edit layout", 0
lvlGenerateMsg:
	.db	"Gen. level...", 0

; RAM VARIABLES
.echo	"The RAM variables begin at "
.echo	$
.echo	".\n"
width:
	.db	0
height:
	.db	0
cellOffsetX: ; In play mode: X offset. In edit mode: current selected cell X
	.db	0
cellOffsetY: ; In play mode: Y offset. In edit mode: current selected cell Y
	.db	0
cellX: ; X coordinate of the currently important cell
	.db	0
cellY: ; X coordinate of the currently important cell
	.db	0
keyOffset:
	.db	6*8+1 ; Row 6 Column 1: That's the 7 key
currFreeCell: ; Address (rel. to dataField) of current free cell
	.db	0
dataFieldSize: ; Product of width and height
	.db	0
dataField:
	.fill	MAX_WIDTH * MAX_HEIGHT, 0
rawDataFieldSize:
	.db	0
rawDataField: ; Data field without walls (temp only, but still required)
	.fill	$ - dataField, 0 ; Make as big as dataField
_shuffle_arrayLength .equ rawDataFieldSize
_shuffle_array .equ rawDataField
amountOfWalls:
	.db	0
fieldLayoutChars:
	.db	T_UNAVAILABLE, "0"
keyPressAction:
	.db	0, 0
dispAction:
	.db	0, 0

.end
.end
